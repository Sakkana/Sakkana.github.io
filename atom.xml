<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>魚のブログ</title>
  
  
  <link href="https://sakkana.github.io/atom.xml" rel="self"/>
  
  <link href="https://sakkana.github.io/"/>
  <updated>2022-01-31T17:44:31.606Z</updated>
  <id>https://sakkana.github.io/</id>
  
  <author>
    <name>Ludovico</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KMP字符串匹配</title>
    <link href="https://sakkana.github.io/2022/02/01/KMP/"/>
    <id>https://sakkana.github.io/2022/02/01/KMP/</id>
    <published>2022-01-31T17:44:01.000Z</published>
    <updated>2022-01-31T17:44:31.606Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p><p>模板串 P 在模式串 S 中多次作为子串出现。</p><p>求出模板串 P 在模式串 S 中所有出现的位置的起始下标。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 N，表示数列长度。</p><p>第二行包含 N 个整数，表示整数数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>第一行输入整数 N，表示字符串 P 的长度。</p><p>第二行输入字符串 P。</p><p>第三行输入整数 M，表示字符串 S 的长度。</p><p>第四行输入字符串 S。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ N ≤ 10<sup>5</sup><br>1 ≤ M ≤ 10<sup>6</sup></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">3aba5ababa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">0 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;// 模式串 ———&gt; 大串// 模板串 ---&gt; 小串const int N = 1e5 + 10, M = 1e6 + 10;   //模板串， 模式串char s[M], p[N];    //模式串string， 模板串patternint ne[N];  // core-&gt;求next数组int n, m;int main(){    cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;         for(int i = 2, j = 0; i &lt;= n; ++ i)    {        while(j &amp;&amp; p[i] != p[j + 1]) j = ne[j];        if(p[i] == p[j + 1]) ++ j;        ne[i] = j;  //一旦到i发现匹配不上，可以回退到j，j是啥？前面两步结局：要么完犊子j=0，要么位于j的字符匹配    }        for(int i = 1, j = 0; i &lt;= m; ++ i)    {        while(j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; // j还有退路(若j = 0则最坏打算，东山再起) &amp;&amp; 未匹配上        if(s[i] == p[j + 1]) ++ j; // 要么完犊子全失败，要么找到一个最大前缀下标        if(j == n)        {            cout &lt;&lt; i - n &lt;&lt; ' ';            j = ne[j];  //继续匹配，看能不能找到最长字串重新出发        }    }        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> 理解KMP模式串匹配，需要理解匹配原理，next代表的含义，求解next方法，以及为什么预处理next数组与匹配过程的原理如出一辙。</p><p> 他们俩唯一的不同是预处理时记录next数组的值，而匹配时没有这一步，取而代之的是检查是否匹配结束。</p><p> 预处理模板串p, next[]数组之和模板串p有关，与模式串S无关。<br> 找后缀和前缀相等的子串，并且力求长度最长。<br> next[i] = j的含义：p[1, j] = p[i - j + 1, i] 一旦模板串中下标j + 1的字符与模式串中下i的字符无法匹配<br> 模板串不吊死在一棵树上，j立马回退，去找max(前缀 == 后缀)的长度<br> 假设这个长度是len, 那么最长后缀的下标为[j - len + 1, j]， 而与之相匹配的前缀下标为[1, len]<br> 因此 next[j]的作用就是回退， 原本是下标j在与模式串比较，一旦不匹配执行next[j]，来到长度len对应的下标继续匹配</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。&lt;/p&gt;
&lt;p&gt;模板串 P 在模式串 S 中多次作为子串出现。&lt;/p&gt;
&lt;p&gt;求出模板串 P 在模式串 S 中所有出现的位置的起始下标。&lt;/p&gt;
&lt;h4 id=&quot;输入格式&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
    <category term="字符串" scheme="https://sakkana.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>单调队列 - 滑动窗口</title>
    <link href="https://sakkana.github.io/2022/02/01/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>https://sakkana.github.io/2022/02/01/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2022-01-31T17:39:01.000Z</published>
    <updated>2022-01-31T17:39:36.025Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个大小为 n ≤ 10<sup>6</sup> 的数组。</p><p>有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。</p><p>你只能在窗口中看到 k 个数字。</p><p>每次滑动窗口向右移动一个位置。</p><p>以下是一个例子：</p><p>该数组为 <code>[1 3 -1 -3 5 3 6 7]</code>，k 为 3。</p><table><thead><tr><th align="left">窗口位置</th><th align="left">最小值</th><th align="left">最大值</th></tr></thead><tbody><tr><td align="left">[1 3 -1] -3 5 3 6 7</td><td align="left">-1</td><td align="left">3</td></tr><tr><td align="left">1 [3 -1 -3] 5 3 6 7</td><td align="left">-3</td><td align="left">3</td></tr><tr><td align="left">1 3 [-1 -3 5] 3 6 7</td><td align="left">-3</td><td align="left">5</td></tr><tr><td align="left">1 3 -1 [-3 5 3] 6 7</td><td align="left">-3</td><td align="left">5</td></tr><tr><td align="left">1 3 -1 -3 [5 3 6] 7</td><td align="left">3</td><td align="left">6</td></tr><tr><td align="left">1 3 -1 -3 5 [3 6 7]</td><td align="left">3</td><td align="left">7</td></tr></tbody></table><p>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含两行。</p><p>第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。</p><p>第二行有 n 个整数，代表数组的具体数值。</p><p>同行数据之间用空格隔开。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出包含两个。</p><p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p><p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">8 31 3 -1 -3 5 3 6 7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">-1 -3 -3 -3 3 33 3 5 5 6 7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N = 1e6 + 10;int a[N], queue[N], n, k;int main(){    cin &gt;&gt; n &gt;&gt; k;    for(int i = 0; i &lt; n; ++ i) cin &gt;&gt; a[i];        int hh = 0, tt = -1;    for(int i = 0; i &lt; n; ++ i)    {        if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; queue[hh]) ++ hh; // 判断队头是否滑出窗口        while(hh &lt;= tt &amp;&amp; a[queue[tt]] &gt;= a[i]) -- tt; // 如果队尾元素&gt;=新元素，队尾一直出队        queue[++ tt] = i;        if(i &gt;= k - 1) cout &lt;&lt; a[queue[hh]] &lt;&lt; ' ';    }        cout &lt;&lt; endl;        hh = 0, tt = -1;    for(int i = 0; i &lt; n; ++ i)    {        if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; queue[hh]) ++ hh;        while(hh &lt;= tt &amp;&amp; a[queue[tt]] &lt;= a[i]) -- tt;        queue[++ tt] = i;        if(i &gt;= k - 1) cout &lt;&lt; a[queue[hh]] &lt;&lt; ' ';    }        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> 队列维护窗口最小值的下标， 队头永远是窗口最小值</p><p>queue中装的不是value，而是Index，方便判断队头最小值下标 queue[hh] 是否滑出窗口临界 i - k + 1</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个大小为 n ≤ 10&lt;sup&gt;6&lt;/sup&gt; 的数组。&lt;/p&gt;
&lt;p&gt;有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。&lt;/p&gt;
&lt;p&gt;你只能在窗口中看到 k 个数字。&lt;/p&gt;
&lt;p&gt;每次滑动窗口向右移动一个位置。&lt;/p&gt;
&lt;p&gt;以下是一个例子：&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://sakkana.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="https://sakkana.github.io/2022/01/31/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>https://sakkana.github.io/2022/01/31/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2022-01-31T06:51:01.000Z</published>
    <updated>2022-01-31T07:04:19.746Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 N，表示数列长度。</p><p>第二行包含 N 个整数，表示整数数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −1。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ N ≤ 10<sup>5</sup><br>1 ≤ 数列中元素 ≤ 10<sup>9</sup></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">53 4 2 7 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">-1 3 -1 2 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int stk[N], tt, n, x;int main(){    cin &gt;&gt; n;        for(int i = 0; i &lt; n; ++ i)    {        scanf("%d", &amp;x);                while(tt &amp;&amp; stk[tt] &gt;= x) -- tt; // stack不为空 &amp;&amp; 栈顶 &gt; 新元素                if(!tt) // 第一个元素 || 序列Min            cout &lt;&lt; -1 &lt;&lt; ' ';        else             cout &lt;&lt; stk[tt] &lt;&lt; ' ';        stk[++ tt] = x; // 新元素进栈    }        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>性质：数字序列中，某些元素永远不会作为答案输出。</p><p>若a<sub>3</sub> &gt; a<sub>5</sub> , 那么a<sub>3</sub>永远也不会作为答案输出。</p><p>只要维护一个栈，栈中元素都是严格单调上升，那么加入新元素时，一旦栈顶top比新元素e1大，则不会是答案，并且在也不会被用到，因为如果后续e2要找左侧第一个比他小的，并不会去找top,而是找e1, 因此一直弹出直到栈顶元素top &lt; 新元素e1。</p></blockquote><blockquote><p>每个元素最多进栈一次，出栈一次，因此每个元素最多被访问2次，n个元素最多被访问2n次，因此时间复杂度O(n)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。&lt;/p&gt;
&lt;h4 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式&quot;&gt;&lt;/a&gt;输入格式&lt;/h4&gt;&lt;p&gt;第一行包含整数 N，</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://sakkana.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>区间合并</title>
    <link href="https://sakkana.github.io/2022/01/31/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    <id>https://sakkana.github.io/2022/01/31/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</id>
    <published>2022-01-31T04:31:01.000Z</published>
    <updated>2022-01-31T05:22:43.188Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个区间 [l<sub>i</sub>, l<sub>r</sub>] ，要求合并所有有交集的区间。</p><p>注意如果在端点处相交，也算有交集。</p><p>输出合并完成后的区间个数。</p><p>例如：[1, 3] 和 [2, 6] 可以合并为一个区间 [1, 6]。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n。</p><p>接下来 n 行，每行包含两个整数 l 和 r</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示合并区间完成后的区间个数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ n ≤ 100000,<br>−10<sup>9</sup> ≤ l<sub>i</sub> ≤ l<sub>r</sub> ≤ 10<sup>9</sup></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">51 22 45 67 87 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;bits/stdc++.h&gt;#define pb push_back#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;typedef vector&lt;PII&gt; vii;int n;vii v;int main(){    cin &gt;&gt; n;    for(int i = 0; i &lt; n; ++i)    {        int a, b;        scanf("%d%d", &amp;a, &amp;b);        v.pb({a, b});    }    sort(v.begin(), v.end());    int ed = -2e9, res = 0;    for(auto it : v)    {        int l = it.x, r = it.y;        if(l &lt;= ed) ed = max(ed, r); //考虑r可能包含在前一个区间里面，对区间拓展没有贡献        else        {            ++ res;            ed = r;        }    }    cout &lt;&lt; res;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>核心还是用贪心的思想贪最长区间是多少，何时区间被打断要更新。</p><blockquote><p>维护什么？</p><ol><li> 当前区间的左端点l &lt;= 维护的右端点ed —&gt; 当前区间包含于前一个区间或者刚好结尾相等</li><li> 当前区间的左端点l 严格&gt; 维护的右端点ed —&gt; 发现一个新的不重复区间，更新区间数量，右端点ed</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定 n 个区间 [l&lt;sub&gt;i&lt;/sub&gt;, l&lt;sub&gt;r&lt;/sub&gt;] ，要求合并所有有交集的区间。&lt;/p&gt;
&lt;p&gt;注意如果在端点处相交，也算有交集。&lt;/p&gt;
&lt;p&gt;输出合并完成后的区间个数。&lt;/p&gt;
&lt;p&gt;例如：[1, 3] 和 [2, 6] 可以合并为一个区间 </summary>
      
    
    
    
    
    <category term="贪心" scheme="https://sakkana.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>容斥原理 - 能被整除的数</title>
    <link href="https://sakkana.github.io/2022/01/31/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    <id>https://sakkana.github.io/2022/01/31/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</id>
    <published>2022-01-30T18:24:01.000Z</published>
    <updated>2022-01-31T17:17:06.234Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数 n 和 m 个不同的质数 p1,p2,…,pm。</p><p>请你求出 1∼n中能被 p1,p2,…,pm中的至少一个数整除的整数有多少个。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n 和 m。</p><p>第二行包含 m 个质数。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示满足条件的整数的个数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ m ≤ 16,<br>1 ≤ n, pi ≤ 109</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">10 22 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 20;   // m个质数， 1 &lt;= m &lt;= 16int primes[N]; int n, m;int main(){    cin &gt;&gt; n &gt;&gt; m;  // 1-n, m个质数for(int i = 0; i &lt; m; ++i) cin &gt;&gt; primes[i];int res = 0;// 枚举2 ^ m种情况for(int i = 1; i &lt; (1 &lt;&lt; m); ++i){    int t = 1, cnt = 0;    for(int j = 0; j &lt; m; ++j)        if(i &gt;&gt; j &amp; 1)        {            ++ cnt; // 统计1的个数，             if((long long)t * primes[j] &gt; n)    // 一旦乘积越界， 直接走人            {                t = -1;                break;            }            t *= primes[j];        }    if(t != -1)    {        if(cnt % 2) res += n / t;        else res -= n / t;    }}   cout &lt;&lt; res;return 0; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>原本暴力遍历时间复杂度： O(n * m)<br>容斥原理：<br>S2 = {2, 4, 6, 8, 10}<br>s3 = {3, 6, 9}</p><p>|S2 ∪ S3| = |S2| + |S3| - |S2 ∩ S3|   O(2 ^ m)<br>m &lt;= 16 —&gt; 65536 计算机1s —&gt; 1e7~ 1e8</p><p>问题转换为， 如何求1 - n中p的倍数?  —&gt; count = ⌊n / p⌋<br>为什么是下取整?<br>hypo1 : n是p的倍数, count =  ⌊n / p⌋ = n / p = k，(p, 2p, 3p, …, kp) 严格等于， 刚好分完<br>hypo2 : n不是p的倍数, count =  ⌊n / p⌋ = k， (p, 2p, 3p, …, kp), n, n比kp大一点点</p><p>|S1| = ⌊n / p1⌋<br>|S2| =  ⌊n / p2⌋<br>|S1 ∩ S2| = ⌊n / (p1 * p2)⌋<br>|S1 ∪ S2| =  ⌊n / p1⌋ + ⌊n / p2⌋   </p><p>求一个交集是做k次乘法 ⌊n / (p1 * p2 * p3 * … * pk)⌋， O(k);<br>一共2 ^ m个集合，O(2 ^ m)<br>===&gt; 总时间复杂度 O(2 ^ m + k)<br>这道题 k = m</p><p>容斥原理 枚举所有项 2 ^ n - 1 （除了所有集合都不选以外）<br>位运算 状态看成n位二进制数， 取1选取0不选<br>共 2 ^ n - 1 个数对应 2 ^ n - 1 种选法<br>检查有多少个1: lowbit把k位右移到最低位再 &amp; 1</p></blockquote><h3 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h3><ul><li>输入</li></ul><blockquote><p>100 3<br>2 3 5</p></blockquote><ul><li>输出</li></ul><blockquote><p>i = 1 t = 2<br>i = 2 t = 3<br>i = 3 t = 6<br>i = 4 t = 5<br>i = 5 t = 10<br>i = 6 t = 15<br>i = 7 t = 30<br>74</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个整数 n 和 m 个不同的质数 p1,p2,…,pm。&lt;/p&gt;
&lt;p&gt;请你求出 1∼n中能被 p1,p2,…,pm中的至少一个数整除的整数有多少个。&lt;/p&gt;
&lt;h4 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
    <category term="数论" scheme="https://sakkana.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>No Title</title>
    <link href="https://sakkana.github.io/2022/01/30/%E6%98%A5%E6%B1%9F%E8%8A%B1%E6%9C%88%E5%A4%9C/"/>
    <id>https://sakkana.github.io/2022/01/30/%E6%98%A5%E6%B1%9F%E8%8A%B1%E6%9C%88%E5%A4%9C/</id>
    <published>2022-01-30T07:06:17.000Z</published>
    <updated>2022-01-30T18:06:00.244Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>春江花月夜</p><blockquote></blockquote><p>唐 · 张若虚</p><p>春江潮水连海平，海上明月共潮生。</p><p>滟滟随波千万里，何处春江无月明！</p><p>江流宛转绕芳甸，月照花林皆似霰；</p><p>空里流霜不觉飞，汀上白沙看不见。</p><p>江天一色无纤尘，皎皎空中孤月轮。</p><p>江畔何人初见月？江月何年初照人？</p><p>人生代代无穷已，江月年年望相似。</p><p>不知江月待何人，但见长江送流水。</p><p>白云一片去悠悠，青枫浦上不胜愁。</p><p>谁家今夜扁舟子？何处相思明月楼？</p><p>可怜楼上月裴回，应照离人妆镜台。</p><p>玉户帘中卷不去，捣衣砧上拂还来。</p><p>此时相望不相闻，愿逐月华流照君。</p><p>鸿雁长飞光不度，鱼龙潜跃水成文。</p><p>昨夜闲潭梦落花，可怜春半不还家。</p><p>江水流春去欲尽，江潭落月复西斜。</p><p>斜月沉沉藏海雾，碣石潇湘无限路。</p><p>不知乘月几人归，落月摇情满江树。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;春江花月夜&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;唐 · 张若虚&lt;/p&gt;
&lt;p&gt;春江潮水连海平，海上明月共潮生。&lt;/p&gt;
&lt;p&gt;滟滟随波千万里，何处春江无月明！&lt;/p&gt;
&lt;p&gt;江流宛转绕芳甸，月照花林皆似霰；&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="测试" scheme="https://sakkana.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>はじめまして！</title>
    <link href="https://sakkana.github.io/2022/01/30/%E9%AD%9A%E3%81%AE%E3%83%96%E3%83%AD%E3%82%B0/"/>
    <id>https://sakkana.github.io/2022/01/30/%E9%AD%9A%E3%81%AE%E3%83%96%E3%83%AD%E3%82%B0/</id>
    <published>2022-01-29T18:29:01.000Z</published>
    <updated>2022-01-30T18:06:07.350Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>I’m a test blog.</p><p>Omit me.</p><p>Farwell.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;I’m a test blog.&lt;/p&gt;
&lt;p&gt;Omit me.&lt;/p&gt;
&lt;p&gt;Farwell.&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    
    <category term="测试" scheme="https://sakkana.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
