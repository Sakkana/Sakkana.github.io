<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>魚のブログ</title>
  
  
  <link href="https://sakkana.github.io/atom.xml" rel="self"/>
  
  <link href="https://sakkana.github.io/"/>
  <updated>2022-01-31T04:42:34.454Z</updated>
  <id>https://sakkana.github.io/</id>
  
  <author>
    <name>Ludovico</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>区间合并</title>
    <link href="https://sakkana.github.io/2022/01/31/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    <id>https://sakkana.github.io/2022/01/31/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</id>
    <published>2022-01-31T04:31:01.000Z</published>
    <updated>2022-01-31T04:42:34.454Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个区间 [l<sub>i</sub>, l<sub>r</sub>] ，要求合并所有有交集的区间。</p><p>注意如果在端点处相交，也算有交集。</p><p>输出合并完成后的区间个数。</p><p>例如：[1, 3] 和 [2, 6] 可以合并为一个区间 [1, 6]。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n。</p><p>接下来 n 行，每行包含两个整数 l 和 r</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示合并区间完成后的区间个数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ n ≤ 100000,<br>−109 ≤ l<sub>i</sub> ≤ l<sub>r</sub> ≤ 109</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">51 22 45 67 87 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;bits/stdc++.h&gt;#define pb push_back#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;typedef vector&lt;PII&gt; vii;int n;vii v;int main(){    cin &gt;&gt; n;    for(int i = 0; i &lt; n; ++i)    {        int a, b;        scanf("%d%d", &amp;a, &amp;b);        v.pb({a, b});    }    sort(v.begin(), v.end());    int ed = -2e9, res = 0;    for(auto it : v)    {        int l = it.x, r = it.y;        if(l &lt;= ed) ed = max(ed, r); //考虑r可能包含在前一个区间里面，对区间拓展没有贡献        else        {            ++ res;            ed = r;        }    }    cout &lt;&lt; res;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>核心还是用贪心的思想贪最长区间是多少，何时区间被打断要更新。</p><blockquote><p>维护什么？</p><ol><li> 当前区间的左端点l &lt;= 维护的右端点ed —&gt; 当前区间包含于前一个区间或者刚好结尾相等</li><li> 当前区间的左端点l 严格&gt; 维护的右端点ed —&gt; 发现一个新的不重复区间，更新区间数量，右端点ed</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定 n 个区间 [l&lt;sub&gt;i&lt;/sub&gt;, l&lt;sub&gt;r&lt;/sub&gt;] ，要求合并所有有交集的区间。&lt;/p&gt;
&lt;p&gt;注意如果在端点处相交，也算有交集。&lt;/p&gt;
&lt;p&gt;输出合并完成后的区间个数。&lt;/p&gt;
&lt;p&gt;例如：[1, 3] 和 [2, 6] 可以合并为一个区间 </summary>
      
    
    
    
    
    <category term="贪心" scheme="https://sakkana.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>能被整除的数 - 容斥原理</title>
    <link href="https://sakkana.github.io/2022/01/31/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%E4%BE%8B%E9%A2%98/"/>
    <id>https://sakkana.github.io/2022/01/31/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%E4%BE%8B%E9%A2%98/</id>
    <published>2022-01-30T18:24:01.000Z</published>
    <updated>2022-01-31T04:37:20.426Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数 n 和 m 个不同的质数 p1,p2,…,pm。</p><p>请你求出 1∼n中能被 p1,p2,…,pm中的至少一个数整除的整数有多少个。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n 和 m。</p><p>第二行包含 m 个质数。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示满足条件的整数的个数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤m≤161≤m≤16,<br>1≤n,pi≤1091≤n,pi≤109</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">10 22 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 20;   // m个质数， 1 &lt;= m &lt;= 16int primes[N]; int n, m;int main(){    cin &gt;&gt; n &gt;&gt; m;  // 1-n, m个质数for(int i = 0; i &lt; m; ++i) cin &gt;&gt; primes[i];int res = 0;// 枚举2 ^ m种情况for(int i = 1; i &lt; (1 &lt;&lt; m); ++i){    int t = 1, cnt = 0;    for(int j = 0; j &lt; m; ++j)        if(i &gt;&gt; j &amp; 1)        {            ++ cnt; // 统计1的个数，             if((long long)t * primes[j] &gt; n)    // 一旦乘积越界， 直接走人            {                t = -1;                break;            }            t *= primes[j];        }    if(t != -1)    {        if(cnt % 2) res += n / t;        else res -= n / t;    }}   cout &lt;&lt; res;return 0; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>原本暴力遍历时间复杂度： O(n * m)<br>容斥原理：<br>S2 = {2, 4, 6, 8, 10}<br>s3 = {3, 6, 9}</p><p>|S2 ∪ S3| = |S2| + |S3| - |S2 ∩ S3|   O(2 ^ m)<br>m &lt;= 16 —&gt; 65536 计算机1s —&gt; 1e7~ 1e8</p><p>问题转换为， 如何求1 - n中p的倍数?  —&gt; count = ⌊n / p⌋<br>为什么是下取整?<br>hypo1 : n是p的倍数, count =  ⌊n / p⌋ = n / p = k，(p, 2p, 3p, …, kp) 严格等于， 刚好分完<br>hypo2 : n不是p的倍数, count =  ⌊n / p⌋ = k， (p, 2p, 3p, …, kp), n, n比kp大一点点</p><p>|S1| = ⌊n / p1⌋<br>|S2| =  ⌊n / p2⌋<br>|S1 ∩ S2| = ⌊n / (p1 * p2)⌋<br>|S1 ∪ S2| =  ⌊n / p1⌋ + ⌊n / p2⌋   </p><p>求一个交集是做k次乘法 ⌊n / (p1 * p2 * p3 * … * pk)⌋， O(k);<br>一共2 ^ m个集合，O(2 ^ m)<br>===&gt; 总时间复杂度 O(2 ^ m + k)<br>这道题 k = m</p><p>容斥原理 枚举所有项 2 ^ n - 1 （除了所有集合都不选以外）<br>位运算 状态看成n位二进制数， 取1选取0不选<br>共 2 ^ n - 1 个数对应 2 ^ n - 1 种选法<br>检查有多少个1: lowbit把k位右移到最低位再 &amp; 1</p></blockquote><h3 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h3><ul><li>输入</li></ul><blockquote><p>100 3<br>2 3 5</p></blockquote><ul><li>输出</li></ul><blockquote><p>i = 1 t = 2<br>i = 2 t = 3<br>i = 3 t = 6<br>i = 4 t = 5<br>i = 5 t = 10<br>i = 6 t = 15<br>i = 7 t = 30<br>74</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个整数 n 和 m 个不同的质数 p1,p2,…,pm。&lt;/p&gt;
&lt;p&gt;请你求出 1∼n中能被 p1,p2,…,pm中的至少一个数整除的整数有多少个。&lt;/p&gt;
&lt;h4 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
    <category term="数论" scheme="https://sakkana.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>No Title</title>
    <link href="https://sakkana.github.io/2022/01/30/%E6%98%A5%E6%B1%9F%E8%8A%B1%E6%9C%88%E5%A4%9C/"/>
    <id>https://sakkana.github.io/2022/01/30/%E6%98%A5%E6%B1%9F%E8%8A%B1%E6%9C%88%E5%A4%9C/</id>
    <published>2022-01-30T07:06:17.000Z</published>
    <updated>2022-01-30T18:06:00.244Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>春江花月夜</p><blockquote></blockquote><p>唐 · 张若虚</p><p>春江潮水连海平，海上明月共潮生。</p><p>滟滟随波千万里，何处春江无月明！</p><p>江流宛转绕芳甸，月照花林皆似霰；</p><p>空里流霜不觉飞，汀上白沙看不见。</p><p>江天一色无纤尘，皎皎空中孤月轮。</p><p>江畔何人初见月？江月何年初照人？</p><p>人生代代无穷已，江月年年望相似。</p><p>不知江月待何人，但见长江送流水。</p><p>白云一片去悠悠，青枫浦上不胜愁。</p><p>谁家今夜扁舟子？何处相思明月楼？</p><p>可怜楼上月裴回，应照离人妆镜台。</p><p>玉户帘中卷不去，捣衣砧上拂还来。</p><p>此时相望不相闻，愿逐月华流照君。</p><p>鸿雁长飞光不度，鱼龙潜跃水成文。</p><p>昨夜闲潭梦落花，可怜春半不还家。</p><p>江水流春去欲尽，江潭落月复西斜。</p><p>斜月沉沉藏海雾，碣石潇湘无限路。</p><p>不知乘月几人归，落月摇情满江树。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;春江花月夜&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;唐 · 张若虚&lt;/p&gt;
&lt;p&gt;春江潮水连海平，海上明月共潮生。&lt;/p&gt;
&lt;p&gt;滟滟随波千万里，何处春江无月明！&lt;/p&gt;
&lt;p&gt;江流宛转绕芳甸，月照花林皆似霰；&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="测试" scheme="https://sakkana.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>はじめまして！</title>
    <link href="https://sakkana.github.io/2022/01/30/%E9%AD%9A%E3%81%AE%E3%83%96%E3%83%AD%E3%82%B0/"/>
    <id>https://sakkana.github.io/2022/01/30/%E9%AD%9A%E3%81%AE%E3%83%96%E3%83%AD%E3%82%B0/</id>
    <published>2022-01-29T18:29:01.000Z</published>
    <updated>2022-01-30T18:06:07.350Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>I’m a test blog.</p><p>Omit me.</p><p>Farwell.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;I’m a test blog.&lt;/p&gt;
&lt;p&gt;Omit me.&lt;/p&gt;
&lt;p&gt;Farwell.&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    
    <category term="测试" scheme="https://sakkana.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
