<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>魚のブログ</title>
  
  
  <link href="https://sakkana.github.io/atom.xml" rel="self"/>
  
  <link href="https://sakkana.github.io/"/>
  <updated>2022-02-02T06:07:10.736Z</updated>
  <id>https://sakkana.github.io/</id>
  
  <author>
    <name>Ludovico</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并查集</title>
    <link href="https://sakkana.github.io/2022/02/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://sakkana.github.io/2022/02/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2022-02-02T06:00:01.000Z</published>
    <updated>2022-02-02T06:07:10.736Z</updated>
    
    <content type="html"><![CDATA[<p>一共有 n 个数，编号是  1 ~ n，最开始每个数各自在一个集合中。</p><p>现在要进行 m 个操作，操作共有两种：</p><ol><li><code>M a b</code>，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li><li><code>Q a b</code>，询问编号为 a 和 b 的两个数是否在同一个集合中；</li></ol><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数 n 和 m。</p><p>接下来 m 行，每行包含一个操作指令，指令为 <code>M a b</code> 或 <code>Q a b</code> 中的一种。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问指令 <code>Q a b</code>，都要输出一个结果，如果 a 和 b 在同一集合内，则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>每个结果占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ n, m ≤ 10<sup>5</sup></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">4 5M 1 2M 3 4Q 1 2Q 1 3Q 3 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">YesNoYes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N = 1e5 + 10;int p[N];int n, m;// 带路径压缩返回祖宗节点int find(int x){    if(p[x] != x) p[x] = find(p[x]);    return p[x];}int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; ++ i) p[i] = i;// 初始化， 刚开始p[i] = i, 每个人都是一个独立的集合        while(m--)    {        char op[2]; //%s吃掉空格，回车... %c会读乱七八糟的字符        int a, b;        scanf("%s%d%d", op, &amp;a, &amp;b);        if(op[0] == 'M') p[find(a)] = find(b);        else        {            if(find(a) == find(b)) puts("Yes");            else puts("No");        }    }        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> 并查集支持操作：</p><p> 1.将两个集合合并<br>  2.询问两个元素是否在同一个集合</p><p>  每一个集合都用一颗树来维护，树根的编号就是整个集合的编号</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一共有 n 个数，编号是  1 ~ n，最开始每个数各自在一个集合中。&lt;/p&gt;
&lt;p&gt;现在要进行 m 个操作，操作共有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;M a b&lt;/code&gt;，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这</summary>
      
    
    
    
    <category term="算法" scheme="https://sakkana.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://sakkana.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>模拟堆</title>
    <link href="https://sakkana.github.io/2022/02/02/%E6%A8%A1%E6%8B%9F%E5%A0%86/"/>
    <id>https://sakkana.github.io/2022/02/02/%E6%A8%A1%E6%8B%9F%E5%A0%86/</id>
    <published>2022-02-02T05:54:01.000Z</published>
    <updated>2022-02-02T06:03:03.751Z</updated>
    
    <content type="html"><![CDATA[<p>维护一个集合，初始时集合为空，支持如下几种操作：</p><ol><li><code>I x</code>，插入一个数 x；</li><li><code>PM</code>，输出当前集合中的最小值；</li><li><code>DM</code>，删除当前集合中的最小值（数据保证此时的最小值唯一）；</li><li><code>D k</code>，删除第 k 个插入的数；</li><li><code>C k x</code>，修改第 k 个插入的数，将其变为 $x$；</li></ol><p>现在要进行 N 次操作，对于所有第 2 个操作，输出当前集合的最小值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 N。</p><p>接下来 N 行，每行包含一个操作指令，操作指令为 <code>I x</code>，<code>PM</code>，<code>DM</code>，<code>D k</code> 或 <code>C k x</code> 中的一种。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个输出指令 <code>PM</code>，输出一个结果，表示当前集合中的最小值。</p><p>每个结果占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ N ≤ 10<sup>5</sup></p><p>−10<sup>9</sup> ≤ x ≤ 10<sup>9</sup><br>数据保证合法。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">8I -10PMI -10D 1C 2 8I 6PMDM<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">-106<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e5 + 10;int h[N], _size, cnt;int in_h[N], h_in[N];   // 第k个插入的点是堆中in_h[k] = j点， 堆中的j号点是第h_in[j] = k个插入的点, 互为反映射void heap_swap(int a, int b) // a, b是堆中的两个下标{    swap(in_h[h_in[a]], in_h[h_in[b]]);  // 插入次序 指向 下标    swap(h_in[a], h_in[b]);     // 下标 指向 插入次序    swap(h[a], h[b]);}void down(int u){    int t = u;    // 三个元素中最小值的下标    if(u * 2 &lt;= _size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;    if(u * 2 + 1 &lt;= _size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;    if(t != u)    {        heap_swap(t, u);        down(t);    }}void up(int u){    if(u / 2 &amp;&amp; h[u / 2] &gt; h[u])    {        heap_swap(u / 2, u);        up(u &gt;&gt; 1);// 当时这里只除以2没有递归，WA了半天    }}int main(){    int _;    cin &gt;&gt; _;    while(_--)    {        int k, x;        char op[10];        scanf("%s", op);                if(!strcmp(op, "I"))    // 插入： 插入最后一个位置， 再up        {            scanf("%d", &amp;x);            ++ cnt, ++ _size;   // 第cnt个插入的元素            in_h[cnt] = _size, h_in[_size] = cnt;            h[_size] = x;            up(_size);        }        else if(!strcmp(op, "PM")) printf("%d\n", h[1]);   // 输出min        else if(!strcmp(op, "DM"))  // 删除min        {            heap_swap(1, _size);            -- _size;            down(1);        }        else if(!strcmp(op, "D"))  // 删除第k个插入的元素        {            scanf("%d", &amp;k);            k = in_h[k];            heap_swap(k, _size);            -- _size;            down(k), up(k);        }        else   // 将第k个插入的元素修改成x        {            scanf("%d%d", &amp;k, &amp;x);            k = in_h[k];            h[k] = x;            down(k), up(k);        }    }        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> 以小根堆为例</p><p> 1.O(logn) 插入一个数    heap[ ++ size] = x, up(size)<br> 2.O(1) 求最小值      heap[1]<br> 3.O(logn) 删除最小值    heap[1] = heap[size –], down(1)<br> 4.删除任意元素  heap[k] = heap[size], down(k), up(k) 只有一个会执行<br> 5.修改任意元素  heap[k] = x, down(k), up(k)</p><p> 堆是一个完全二叉树，除了最后一层节点，上面所有结点都是满的，最后一层节点从左到右排列<br> 每个节点都&lt;=左右儿子， 因此根节点是整个集合的最小值</p><p> 全新存储方式：一维数组</p><pre><code>                     1             2               3       4          5      6         7      8  9      10 11  12 13     14 15</code></pre><p> ​<br>         x<br>     2x     2x+1</p><p> 某个结点下标x的左儿子：2x，右儿子：2x+1</p><p> 核心操作： down() &amp; up() </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;维护一个集合，初始时集合为空，支持如下几种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;I x&lt;/code&gt;，插入一个数 x；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PM&lt;/code&gt;，输出当前集合中的最小值；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DM&lt;/code&gt;，删除当前集合中的最小</summary>
      
    
    
    
    <category term="算法" scheme="https://sakkana.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://sakkana.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="https://sakkana.github.io/2022/02/02/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>https://sakkana.github.io/2022/02/02/%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2022-02-02T05:50:01.000Z</published>
    <updated>2022-02-02T06:02:44.380Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个长度为 n 的整数数列，从小到大输出前 m 小的数。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n 和 m。</p><p>第二行包含 n 个整数，表示整数数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 m 个整数，表示整数数列中前 m 小的数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ m ≤ n ≤ 10<sup>5</sup>，<br>1 ≤ 数列中元素 ≤ 10<sup>9</sup></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">5 34 5 1 3 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">1 2 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e5 + 10;int h[N], _size;int n, m;void down(int u){    int t = u;    // 三个元素中最小值的下标    if(u * 2 &lt;= _size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;    if(u * 2 + 1 &lt;= _size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;    if(t != u)    {        swap(h[u], h[t]);        down(t);    }}int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; ++ i) scanf("%d", &amp;h[i]);    _size = n;    // O(n)建堆    for(int i = n / 2; i; -- i) down(i);    // n / 2向下取整 是最后一个非叶子节点 差比数列求和 &lt; n    while(m--)    {        printf("%d ", h[1]);        h[1] = h[_size --];        down(1);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">// down函数非递归写法void down(int u){    int t = -1;    while(true)    {        t = u;    // 三个元素中最小值的下标        if(u * 2 &lt;= _size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;        if(u * 2 + 1 &lt;= _size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;        if(t == u) break;        swap(h[u], h[t]);        u = t;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  以小根堆为例</p><p> 1.O(logn) 插入一个数    heap[ ++ size] = x, up(size)<br> 2.O(1) 求最小值      heap[1]<br> 3.O(logn) 删除最小值    heap[1] = heap[size –], down(1)<br> 4.O(logn) 删除任意元素  heap[k] = heap[size], down(k), up(k) 只有一个会执行<br> 5.O(logn) 修改任意元素  heap[k] = x, down(k), up(k)</p><p> 堆是一个完全二叉树，除了最后一层节点，上面所有结点都是满的，最后一层节点从左到右排列<br> 每个节点都&lt;=左右儿子， 因此根节点是整个集合的最小值</p><p> 全新存储方式：一维数组</p><pre><code>                     1             2                3       4          5       6         7     8   9     10   11  12  13    14  15     x 2x     2x+1</code></pre><p> 某个结点x的左儿子：2x，右儿子：2x+1</p><p> 核心操作： down() &amp; up() </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;输入一个长度为 n 的整数数列，从小到大输出前 m 小的数。&lt;/p&gt;
&lt;h4 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式&quot;&gt;&lt;/a&gt;输入格式&lt;/h4&gt;&lt;p&gt;第一行包含整数 n 和 m。&lt;/p&gt;
&lt;p&gt;第二</summary>
      
    
    
    
    <category term="算法" scheme="https://sakkana.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://sakkana.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>KMP字符串匹配</title>
    <link href="https://sakkana.github.io/2022/02/01/KMP/"/>
    <id>https://sakkana.github.io/2022/02/01/KMP/</id>
    <published>2022-01-31T17:44:01.000Z</published>
    <updated>2022-01-31T18:04:06.282Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p><p>模板串 P 在模式串 S 中多次作为子串出现。</p><p>求出模板串 P 在模式串 S 中所有出现的位置的起始下标。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 N，表示数列长度。</p><p>第二行包含 N 个整数，表示整数数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>第一行输入整数 N，表示字符串 P 的长度。</p><p>第二行输入字符串 P。</p><p>第三行输入整数 M，表示字符串 S 的长度。</p><p>第四行输入字符串 S。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ N ≤ 10<sup>5</sup><br>1 ≤ M ≤ 10<sup>6</sup></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">3aba5ababa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">0 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;// 模式串 ———&gt; 大串// 模板串 ---&gt; 小串const int N = 1e5 + 10, M = 1e6 + 10;   //模板串， 模式串char s[M], p[N];    //模式串string， 模板串patternint ne[N];  // core-&gt;求next数组int n, m;int main(){    cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;         for(int i = 2, j = 0; i &lt;= n; ++ i)    {        while(j &amp;&amp; p[i] != p[j + 1]) j = ne[j];        if(p[i] == p[j + 1]) ++ j;        ne[i] = j;  //一旦到i发现匹配不上，可以回退到j，j是啥？前面两步结局：要么完犊子j=0，要么位于j的字符匹配    }        for(int i = 1, j = 0; i &lt;= m; ++ i)    {        while(j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; // j还有退路(若j = 0则最坏打算，东山再起) &amp;&amp; 未匹配上        if(s[i] == p[j + 1]) ++ j; // 要么完犊子全失败，要么找到一个最大前缀下标        if(j == n)        {            cout &lt;&lt; i - n &lt;&lt; ' ';            j = ne[j];  //继续匹配，看能不能找到最长字串重新出发        }    }        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> 理解KMP模式串匹配，需要理解匹配原理，next代表的含义，求解next方法，以及为什么预处理next数组与匹配过程的原理如出一辙。</p><p> 他们俩唯一的不同是预处理时记录next数组的值，而匹配时没有这一步，取而代之的是检查是否匹配结束。</p><p> 预处理模板串p, next[]数组之和模板串p有关，与模式串S无关。<br> 找后缀和前缀相等的子串，并且力求长度最长。<br> next[i] = j的含义：p[1, j] = p[i - j + 1, i] 一旦模板串中下标j + 1的字符与模式串中下i的字符无法匹配<br> 模板串不吊死在一棵树上，j立马回退，去找max(前缀 == 后缀)的长度<br> 假设这个长度是len, 那么最长后缀的下标为[j - len + 1, j]， 而与之相匹配的前缀下标为[1, len]<br> 因此 next[j]的作用就是回退， 原本是下标j在与模式串比较，一旦不匹配执行next[j]，来到长度len对应的下标继续匹配</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。&lt;/p&gt;
&lt;p&gt;模板串 P 在模式串 S 中多次作为子串出现。&lt;/p&gt;
&lt;p&gt;求出模板串 P 在模式串 S 中所有出现的位置的起始下标。&lt;/p&gt;
&lt;h4 id=&quot;输入格式&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="算法" scheme="https://sakkana.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="字符串" scheme="https://sakkana.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>单调队列 - 滑动窗口</title>
    <link href="https://sakkana.github.io/2022/02/01/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>https://sakkana.github.io/2022/02/01/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2022-01-31T17:39:01.000Z</published>
    <updated>2022-01-31T18:03:58.420Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个大小为 n ≤ 10<sup>6</sup> 的数组。</p><p>有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。</p><p>你只能在窗口中看到 k 个数字。</p><p>每次滑动窗口向右移动一个位置。</p><p>以下是一个例子：</p><p>该数组为 <code>[1 3 -1 -3 5 3 6 7]</code>，k 为 3。</p><table><thead><tr><th align="left">窗口位置</th><th align="left">最小值</th><th align="left">最大值</th></tr></thead><tbody><tr><td align="left">[1 3 -1] -3 5 3 6 7</td><td align="left">-1</td><td align="left">3</td></tr><tr><td align="left">1 [3 -1 -3] 5 3 6 7</td><td align="left">-3</td><td align="left">3</td></tr><tr><td align="left">1 3 [-1 -3 5] 3 6 7</td><td align="left">-3</td><td align="left">5</td></tr><tr><td align="left">1 3 -1 [-3 5 3] 6 7</td><td align="left">-3</td><td align="left">5</td></tr><tr><td align="left">1 3 -1 -3 [5 3 6] 7</td><td align="left">3</td><td align="left">6</td></tr><tr><td align="left">1 3 -1 -3 5 [3 6 7]</td><td align="left">3</td><td align="left">7</td></tr></tbody></table><p>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含两行。</p><p>第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。</p><p>第二行有 n 个整数，代表数组的具体数值。</p><p>同行数据之间用空格隔开。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出包含两个。</p><p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p><p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">8 31 3 -1 -3 5 3 6 7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">-1 -3 -3 -3 3 33 3 5 5 6 7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N = 1e6 + 10;int a[N], queue[N], n, k;int main(){    cin &gt;&gt; n &gt;&gt; k;    for(int i = 0; i &lt; n; ++ i) cin &gt;&gt; a[i];        int hh = 0, tt = -1;    for(int i = 0; i &lt; n; ++ i)    {        if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; queue[hh]) ++ hh; // 判断队头是否滑出窗口        while(hh &lt;= tt &amp;&amp; a[queue[tt]] &gt;= a[i]) -- tt; // 如果队尾元素&gt;=新元素，队尾一直出队        queue[++ tt] = i;        if(i &gt;= k - 1) cout &lt;&lt; a[queue[hh]] &lt;&lt; ' ';    }        cout &lt;&lt; endl;        hh = 0, tt = -1;    for(int i = 0; i &lt; n; ++ i)    {        if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; queue[hh]) ++ hh;        while(hh &lt;= tt &amp;&amp; a[queue[tt]] &lt;= a[i]) -- tt;        queue[++ tt] = i;        if(i &gt;= k - 1) cout &lt;&lt; a[queue[hh]] &lt;&lt; ' ';    }        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> 队列维护窗口最小值的下标， 队头永远是窗口最小值</p><p>queue中装的不是value，而是Index，方便判断队头最小值下标 queue[hh] 是否滑出窗口临界 i - k + 1</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个大小为 n ≤ 10&lt;sup&gt;6&lt;/sup&gt; 的数组。&lt;/p&gt;
&lt;p&gt;有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。&lt;/p&gt;
&lt;p&gt;你只能在窗口中看到 k 个数字。&lt;/p&gt;
&lt;p&gt;每次滑动窗口向右移动一个位置。&lt;/p&gt;
&lt;p&gt;以下是一个例子：&lt;/p&gt;
</summary>
      
    
    
    
    <category term="算法" scheme="https://sakkana.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://sakkana.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="https://sakkana.github.io/2022/01/31/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>https://sakkana.github.io/2022/01/31/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2022-01-31T06:51:01.000Z</published>
    <updated>2022-01-31T18:04:15.718Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 N，表示数列长度。</p><p>第二行包含 N 个整数，表示整数数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −1。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ N ≤ 10<sup>5</sup><br>1 ≤ 数列中元素 ≤ 10<sup>9</sup></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">53 4 2 7 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">-1 3 -1 2 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int stk[N], tt, n, x;int main(){    cin &gt;&gt; n;        for(int i = 0; i &lt; n; ++ i)    {        scanf("%d", &amp;x);                while(tt &amp;&amp; stk[tt] &gt;= x) -- tt; // stack不为空 &amp;&amp; 栈顶 &gt; 新元素                if(!tt) // 第一个元素 || 序列Min            cout &lt;&lt; -1 &lt;&lt; ' ';        else             cout &lt;&lt; stk[tt] &lt;&lt; ' ';        stk[++ tt] = x; // 新元素进栈    }        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>性质：数字序列中，某些元素永远不会作为答案输出。</p><p>若a<sub>3</sub> &gt; a<sub>5</sub> , 那么a<sub>3</sub>永远也不会作为答案输出。</p><p>只要维护一个栈，栈中元素都是严格单调上升，那么加入新元素时，一旦栈顶top比新元素e1大，则不会是答案，并且在也不会被用到，因为如果后续e2要找左侧第一个比他小的，并不会去找top,而是找e1, 因此一直弹出直到栈顶元素top &lt; 新元素e1。</p></blockquote><blockquote><p>每个元素最多进栈一次，出栈一次，因此每个元素最多被访问2次，n个元素最多被访问2n次，因此时间复杂度O(n)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。&lt;/p&gt;
&lt;h4 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式&quot;&gt;&lt;/a&gt;输入格式&lt;/h4&gt;&lt;p&gt;第一行包含整数 N，</summary>
      
    
    
    
    <category term="算法" scheme="https://sakkana.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://sakkana.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Trie树</title>
    <link href="https://sakkana.github.io/2022/01/31/Trie%E6%A0%91/"/>
    <id>https://sakkana.github.io/2022/01/31/Trie%E6%A0%91/</id>
    <published>2022-01-31T06:51:01.000Z</published>
    <updated>2022-02-01T11:40:51.691Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 N，表示数列长度。</p><p>第二行包含 N 个整数，表示整数数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −1。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ N ≤ 10<sup>5</sup><br>1 ≤ 数列中元素 ≤ 10<sup>9</sup></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">53 4 2 7 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">-1 3 -1 2 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int stk[N], tt, n, x;int main(){    cin &gt;&gt; n;        for(int i = 0; i &lt; n; ++ i)    {        scanf("%d", &amp;x);                while(tt &amp;&amp; stk[tt] &gt;= x) -- tt; // stack不为空 &amp;&amp; 栈顶 &gt; 新元素                if(!tt) // 第一个元素 || 序列Min            cout &lt;&lt; -1 &lt;&lt; ' ';        else             cout &lt;&lt; stk[tt] &lt;&lt; ' ';        stk[++ tt] = x; // 新元素进栈    }        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>性质：数字序列中，某些元素永远不会作为答案输出。</p><p>若a<sub>3</sub> &gt; a<sub>5</sub> , 那么a<sub>3</sub>永远也不会作为答案输出。</p><p>只要维护一个栈，栈中元素都是严格单调上升，那么加入新元素时，一旦栈顶top比新元素e1大，则不会是答案，并且在也不会被用到，因为如果后续e2要找左侧第一个比他小的，并不会去找top,而是找e1, 因此一直弹出直到栈顶元素top &lt; 新元素e1。</p></blockquote><blockquote><p>每个元素最多进栈一次，出栈一次，因此每个元素最多被访问2次，n个元素最多被访问2n次，因此时间复杂度O(n)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。&lt;/p&gt;
&lt;h4 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式&quot;&gt;&lt;/a&gt;输入格式&lt;/h4&gt;&lt;p&gt;第一行包含整数 N，</summary>
      
    
    
    
    <category term="算法" scheme="https://sakkana.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://sakkana.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>区间合并</title>
    <link href="https://sakkana.github.io/2022/01/31/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    <id>https://sakkana.github.io/2022/01/31/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</id>
    <published>2022-01-31T04:31:01.000Z</published>
    <updated>2022-01-31T18:03:09.024Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个区间 [l<sub>i</sub>, l<sub>r</sub>] ，要求合并所有有交集的区间。</p><p>注意如果在端点处相交，也算有交集。</p><p>输出合并完成后的区间个数。</p><p>例如：[1, 3] 和 [2, 6] 可以合并为一个区间 [1, 6]。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n。</p><p>接下来 n 行，每行包含两个整数 l 和 r</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示合并区间完成后的区间个数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ n ≤ 100000,<br>−10<sup>9</sup> ≤ l<sub>i</sub> ≤ l<sub>r</sub> ≤ 10<sup>9</sup></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">51 22 45 67 87 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;bits/stdc++.h&gt;#define pb push_back#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;typedef vector&lt;PII&gt; vii;int n;vii v;int main(){    cin &gt;&gt; n;    for(int i = 0; i &lt; n; ++i)    {        int a, b;        scanf("%d%d", &amp;a, &amp;b);        v.pb({a, b});    }    sort(v.begin(), v.end());    int ed = -2e9, res = 0;    for(auto it : v)    {        int l = it.x, r = it.y;        if(l &lt;= ed) ed = max(ed, r); //考虑r可能包含在前一个区间里面，对区间拓展没有贡献        else        {            ++ res;            ed = r;        }    }    cout &lt;&lt; res;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>核心还是用贪心的思想贪最长区间是多少，何时区间被打断要更新。</p><blockquote><p>维护什么？</p><ol><li> 当前区间的左端点l &lt;= 维护的右端点ed —&gt; 当前区间包含于前一个区间或者刚好结尾相等</li><li> 当前区间的左端点l 严格&gt; 维护的右端点ed —&gt; 发现一个新的不重复区间，更新区间数量，右端点ed</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定 n 个区间 [l&lt;sub&gt;i&lt;/sub&gt;, l&lt;sub&gt;r&lt;/sub&gt;] ，要求合并所有有交集的区间。&lt;/p&gt;
&lt;p&gt;注意如果在端点处相交，也算有交集。&lt;/p&gt;
&lt;p&gt;输出合并完成后的区间个数。&lt;/p&gt;
&lt;p&gt;例如：[1, 3] 和 [2, 6] 可以合并为一个区间 </summary>
      
    
    
    
    <category term="算法" scheme="https://sakkana.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="贪心" scheme="https://sakkana.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>容斥原理 - 能被整除的数</title>
    <link href="https://sakkana.github.io/2022/01/31/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    <id>https://sakkana.github.io/2022/01/31/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</id>
    <published>2022-01-30T18:24:01.000Z</published>
    <updated>2022-01-31T18:03:51.437Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数 n 和 m 个不同的质数 p1,p2,…,pm。</p><p>请你求出 1∼n中能被 p1,p2,…,pm中的至少一个数整除的整数有多少个。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n 和 m。</p><p>第二行包含 m 个质数。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示满足条件的整数的个数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ m ≤ 16,<br>1 ≤ n, pi ≤ 109</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">10 22 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 20;   // m个质数， 1 &lt;= m &lt;= 16int primes[N]; int n, m;int main(){    cin &gt;&gt; n &gt;&gt; m;  // 1-n, m个质数for(int i = 0; i &lt; m; ++i) cin &gt;&gt; primes[i];int res = 0;// 枚举2 ^ m种情况for(int i = 1; i &lt; (1 &lt;&lt; m); ++i){    int t = 1, cnt = 0;    for(int j = 0; j &lt; m; ++j)        if(i &gt;&gt; j &amp; 1)        {            ++ cnt; // 统计1的个数，             if((long long)t * primes[j] &gt; n)    // 一旦乘积越界， 直接走人            {                t = -1;                break;            }            t *= primes[j];        }    if(t != -1)    {        if(cnt % 2) res += n / t;        else res -= n / t;    }}   cout &lt;&lt; res;return 0; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>原本暴力遍历时间复杂度： O(n * m)<br>容斥原理：<br>S2 = {2, 4, 6, 8, 10}<br>s3 = {3, 6, 9}</p><p>|S2 ∪ S3| = |S2| + |S3| - |S2 ∩ S3|   O(2 ^ m)<br>m &lt;= 16 —&gt; 65536 计算机1s —&gt; 1e7~ 1e8</p><p>问题转换为， 如何求1 - n中p的倍数?  —&gt; count = ⌊n / p⌋<br>为什么是下取整?<br>hypo1 : n是p的倍数, count =  ⌊n / p⌋ = n / p = k，(p, 2p, 3p, …, kp) 严格等于， 刚好分完<br>hypo2 : n不是p的倍数, count =  ⌊n / p⌋ = k， (p, 2p, 3p, …, kp), n, n比kp大一点点</p><p>|S1| = ⌊n / p1⌋<br>|S2| =  ⌊n / p2⌋<br>|S1 ∩ S2| = ⌊n / (p1 * p2)⌋<br>|S1 ∪ S2| =  ⌊n / p1⌋ + ⌊n / p2⌋   </p><p>求一个交集是做k次乘法 ⌊n / (p1 * p2 * p3 * … * pk)⌋， O(k);<br>一共2 ^ m个集合，O(2 ^ m)<br>===&gt; 总时间复杂度 O(2 ^ m + k)<br>这道题 k = m</p><p>容斥原理 枚举所有项 2 ^ n - 1 （除了所有集合都不选以外）<br>位运算 状态看成n位二进制数， 取1选取0不选<br>共 2 ^ n - 1 个数对应 2 ^ n - 1 种选法<br>检查有多少个1: lowbit把k位右移到最低位再 &amp; 1</p></blockquote><h3 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h3><ul><li>输入</li></ul><blockquote><p>100 3<br>2 3 5</p></blockquote><ul><li>输出</li></ul><blockquote><p>i = 1 t = 2<br>i = 2 t = 3<br>i = 3 t = 6<br>i = 4 t = 5<br>i = 5 t = 10<br>i = 6 t = 15<br>i = 7 t = 30<br>74</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个整数 n 和 m 个不同的质数 p1,p2,…,pm。&lt;/p&gt;
&lt;p&gt;请你求出 1∼n中能被 p1,p2,…,pm中的至少一个数整除的整数有多少个。&lt;/p&gt;
&lt;h4 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="算法" scheme="https://sakkana.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数论" scheme="https://sakkana.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>No Title</title>
    <link href="https://sakkana.github.io/2022/01/30/%E6%98%A5%E6%B1%9F%E8%8A%B1%E6%9C%88%E5%A4%9C/"/>
    <id>https://sakkana.github.io/2022/01/30/%E6%98%A5%E6%B1%9F%E8%8A%B1%E6%9C%88%E5%A4%9C/</id>
    <published>2022-01-30T07:06:17.000Z</published>
    <updated>2022-01-30T18:06:00.244Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>春江花月夜</p><blockquote></blockquote><p>唐 · 张若虚</p><p>春江潮水连海平，海上明月共潮生。</p><p>滟滟随波千万里，何处春江无月明！</p><p>江流宛转绕芳甸，月照花林皆似霰；</p><p>空里流霜不觉飞，汀上白沙看不见。</p><p>江天一色无纤尘，皎皎空中孤月轮。</p><p>江畔何人初见月？江月何年初照人？</p><p>人生代代无穷已，江月年年望相似。</p><p>不知江月待何人，但见长江送流水。</p><p>白云一片去悠悠，青枫浦上不胜愁。</p><p>谁家今夜扁舟子？何处相思明月楼？</p><p>可怜楼上月裴回，应照离人妆镜台。</p><p>玉户帘中卷不去，捣衣砧上拂还来。</p><p>此时相望不相闻，愿逐月华流照君。</p><p>鸿雁长飞光不度，鱼龙潜跃水成文。</p><p>昨夜闲潭梦落花，可怜春半不还家。</p><p>江水流春去欲尽，江潭落月复西斜。</p><p>斜月沉沉藏海雾，碣石潇湘无限路。</p><p>不知乘月几人归，落月摇情满江树。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;春江花月夜&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;唐 · 张若虚&lt;/p&gt;
&lt;p&gt;春江潮水连海平，海上明月共潮生。&lt;/p&gt;
&lt;p&gt;滟滟随波千万里，何处春江无月明！&lt;/p&gt;
&lt;p&gt;江流宛转绕芳甸，月照花林皆似霰；&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="测试" scheme="https://sakkana.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>はじめまして！</title>
    <link href="https://sakkana.github.io/2022/01/30/%E9%AD%9A%E3%81%AE%E3%83%96%E3%83%AD%E3%82%B0/"/>
    <id>https://sakkana.github.io/2022/01/30/%E9%AD%9A%E3%81%AE%E3%83%96%E3%83%AD%E3%82%B0/</id>
    <published>2022-01-29T18:29:01.000Z</published>
    <updated>2022-01-30T18:06:07.350Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>I’m a test blog.</p><p>Omit me.</p><p>Farwell.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;I’m a test blog.&lt;/p&gt;
&lt;p&gt;Omit me.&lt;/p&gt;
&lt;p&gt;Farwell.&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    
    <category term="测试" scheme="https://sakkana.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
