<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>单调栈</title>
      <link href="/2022/01/31/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2022/01/31/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 N，表示数列长度。</p><p>第二行包含 N 个整数，表示整数数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −1。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ N ≤ 10<sup>5</sup><br>1 ≤ 数列中元素 ≤ 10<sup>9</sup></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">53 4 2 7 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">-1 3 -1 2 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int stk[N], tt, n, x;int main(){    cin &gt;&gt; n;        for(int i = 0; i &lt; n; ++ i)    {        scanf("%d", &amp;x);                while(tt &amp;&amp; stk[tt] &gt;= x) -- tt; // stack不为空 &amp;&amp; 栈顶 &gt; 新元素                if(!tt) // 第一个元素 || 序列Min            cout &lt;&lt; -1 &lt;&lt; ' ';        else             cout &lt;&lt; stk[tt] &lt;&lt; ' ';        stk[++ tt] = x; // 新元素进栈    }        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>性质：数字序列中，某些元素永远不会作为答案输出。</p><p>若a<sub>3</sub> &gt; a<sub>5</sub> , 那么a<sub>3</sub>永远也不会作为答案输出。</p><p>只要维护一个栈，栈中元素都是严格单调上升，那么加入新元素时，一旦栈顶top比新元素e1大，则不会是答案，并且在也不会被用到，因为如果后续e2要找左侧第一个比他小的，并不会去找top,而是找e1, 因此一直弹出直到栈顶元素top &lt; 新元素e1。</p></blockquote><blockquote><p>每个元素最多进栈一次，出栈一次，因此每个元素最多被访问2次，n个元素最多被访问2n次，因此时间复杂度O(n)</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间合并</title>
      <link href="/2022/01/31/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
      <url>/2022/01/31/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<p>给定 n 个区间 [l<sub>i</sub>, l<sub>r</sub>] ，要求合并所有有交集的区间。</p><p>注意如果在端点处相交，也算有交集。</p><p>输出合并完成后的区间个数。</p><p>例如：[1, 3] 和 [2, 6] 可以合并为一个区间 [1, 6]。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n。</p><p>接下来 n 行，每行包含两个整数 l 和 r</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示合并区间完成后的区间个数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ n ≤ 100000,<br>−10<sup>9</sup> ≤ l<sub>i</sub> ≤ l<sub>r</sub> ≤ 10<sup>9</sup></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">51 22 45 67 87 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;bits/stdc++.h&gt;#define pb push_back#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;typedef vector&lt;PII&gt; vii;int n;vii v;int main(){    cin &gt;&gt; n;    for(int i = 0; i &lt; n; ++i)    {        int a, b;        scanf("%d%d", &amp;a, &amp;b);        v.pb({a, b});    }    sort(v.begin(), v.end());    int ed = -2e9, res = 0;    for(auto it : v)    {        int l = it.x, r = it.y;        if(l &lt;= ed) ed = max(ed, r); //考虑r可能包含在前一个区间里面，对区间拓展没有贡献        else        {            ++ res;            ed = r;        }    }    cout &lt;&lt; res;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>核心还是用贪心的思想贪最长区间是多少，何时区间被打断要更新。</p><blockquote><p>维护什么？</p><ol><li> 当前区间的左端点l &lt;= 维护的右端点ed —&gt; 当前区间包含于前一个区间或者刚好结尾相等</li><li> 当前区间的左端点l 严格&gt; 维护的右端点ed —&gt; 发现一个新的不重复区间，更新区间数量，右端点ed</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>能被整除的数 - 容斥原理</title>
      <link href="/2022/01/31/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
      <url>/2022/01/31/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数 n 和 m 个不同的质数 p1,p2,…,pm。</p><p>请你求出 1∼n中能被 p1,p2,…,pm中的至少一个数整除的整数有多少个。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n 和 m。</p><p>第二行包含 m 个质数。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示满足条件的整数的个数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ m ≤ 16,<br>1 ≤ n, pi ≤ 109</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">10 22 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 20;   // m个质数， 1 &lt;= m &lt;= 16int primes[N]; int n, m;int main(){    cin &gt;&gt; n &gt;&gt; m;  // 1-n, m个质数for(int i = 0; i &lt; m; ++i) cin &gt;&gt; primes[i];int res = 0;// 枚举2 ^ m种情况for(int i = 1; i &lt; (1 &lt;&lt; m); ++i){    int t = 1, cnt = 0;    for(int j = 0; j &lt; m; ++j)        if(i &gt;&gt; j &amp; 1)        {            ++ cnt; // 统计1的个数，             if((long long)t * primes[j] &gt; n)    // 一旦乘积越界， 直接走人            {                t = -1;                break;            }            t *= primes[j];        }    if(t != -1)    {        if(cnt % 2) res += n / t;        else res -= n / t;    }}   cout &lt;&lt; res;return 0; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>原本暴力遍历时间复杂度： O(n * m)<br>容斥原理：<br>S2 = {2, 4, 6, 8, 10}<br>s3 = {3, 6, 9}</p><p>|S2 ∪ S3| = |S2| + |S3| - |S2 ∩ S3|   O(2 ^ m)<br>m &lt;= 16 —&gt; 65536 计算机1s —&gt; 1e7~ 1e8</p><p>问题转换为， 如何求1 - n中p的倍数?  —&gt; count = ⌊n / p⌋<br>为什么是下取整?<br>hypo1 : n是p的倍数, count =  ⌊n / p⌋ = n / p = k，(p, 2p, 3p, …, kp) 严格等于， 刚好分完<br>hypo2 : n不是p的倍数, count =  ⌊n / p⌋ = k， (p, 2p, 3p, …, kp), n, n比kp大一点点</p><p>|S1| = ⌊n / p1⌋<br>|S2| =  ⌊n / p2⌋<br>|S1 ∩ S2| = ⌊n / (p1 * p2)⌋<br>|S1 ∪ S2| =  ⌊n / p1⌋ + ⌊n / p2⌋   </p><p>求一个交集是做k次乘法 ⌊n / (p1 * p2 * p3 * … * pk)⌋， O(k);<br>一共2 ^ m个集合，O(2 ^ m)<br>===&gt; 总时间复杂度 O(2 ^ m + k)<br>这道题 k = m</p><p>容斥原理 枚举所有项 2 ^ n - 1 （除了所有集合都不选以外）<br>位运算 状态看成n位二进制数， 取1选取0不选<br>共 2 ^ n - 1 个数对应 2 ^ n - 1 种选法<br>检查有多少个1: lowbit把k位右移到最低位再 &amp; 1</p></blockquote><h3 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h3><ul><li>输入</li></ul><blockquote><p>100 3<br>2 3 5</p></blockquote><ul><li>输出</li></ul><blockquote><p>i = 1 t = 2<br>i = 2 t = 3<br>i = 3 t = 6<br>i = 4 t = 5<br>i = 5 t = 10<br>i = 6 t = 15<br>i = 7 t = 30<br>74</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>No Title</title>
      <link href="/2022/01/30/%E6%98%A5%E6%B1%9F%E8%8A%B1%E6%9C%88%E5%A4%9C/"/>
      <url>/2022/01/30/%E6%98%A5%E6%B1%9F%E8%8A%B1%E6%9C%88%E5%A4%9C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>春江花月夜</p><blockquote></blockquote><p>唐 · 张若虚</p><p>春江潮水连海平，海上明月共潮生。</p><p>滟滟随波千万里，何处春江无月明！</p><p>江流宛转绕芳甸，月照花林皆似霰；</p><p>空里流霜不觉飞，汀上白沙看不见。</p><p>江天一色无纤尘，皎皎空中孤月轮。</p><p>江畔何人初见月？江月何年初照人？</p><p>人生代代无穷已，江月年年望相似。</p><p>不知江月待何人，但见长江送流水。</p><p>白云一片去悠悠，青枫浦上不胜愁。</p><p>谁家今夜扁舟子？何处相思明月楼？</p><p>可怜楼上月裴回，应照离人妆镜台。</p><p>玉户帘中卷不去，捣衣砧上拂还来。</p><p>此时相望不相闻，愿逐月华流照君。</p><p>鸿雁长飞光不度，鱼龙潜跃水成文。</p><p>昨夜闲潭梦落花，可怜春半不还家。</p><p>江水流春去欲尽，江潭落月复西斜。</p><p>斜月沉沉藏海雾，碣石潇湘无限路。</p><p>不知乘月几人归，落月摇情满江树。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>はじめまして！</title>
      <link href="/2022/01/30/%E9%AD%9A%E3%81%AE%E3%83%96%E3%83%AD%E3%82%B0/"/>
      <url>/2022/01/30/%E9%AD%9A%E3%81%AE%E3%83%96%E3%83%AD%E3%82%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>I’m a test blog.</p><p>Omit me.</p><p>Farwell.</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
